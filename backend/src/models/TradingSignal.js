/**
 * TradingSignal Model
 * Stores trading signals generated by the AI system
 */

const { DataTypes, Op } = require('sequelize');
const { sequelize } = require('../config/database');

/**
 * TradingSignal model for storing and tracking trading signals
 */
const TradingSignal = sequelize.define('TradingSignal', {
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true,
  },
  userId: {
    type: DataTypes.UUID,
    allowNull: true, // null for system-wide signals
    references: {
      model: 'users',
      key: 'id',
    },
  },
  pair: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      is: /^[A-Z]{3}\/[A-Z]{3}$/,
    },
  },
  timeframe: {
    type: DataTypes.ENUM('1min', '5min', '15min', '30min', '1h', '4h', '1d', '1w', '1M'),
    allowNull: false,
  },
  signal: {
    type: DataTypes.ENUM('buy', 'sell', 'hold'),
    allowNull: false,
    field: 'action',
  },
  confidence: {
    type: DataTypes.DECIMAL(3, 2),
    allowNull: false,
    validate: {
      min: 0.0,
      max: 1.0,
    },
  },
  // ML prediction factors (as per CLAUDE.md ML model format)
  factors: {
    type: DataTypes.JSON,
    allowNull: false,
    defaultValue: {
      technical: 0.0,
      sentiment: 0.0,
      pattern: 0.0,
    },
    validate: {
      isValidFactors(value) {
        if (typeof value !== 'object' || value === null) {
          throw new Error('Factors must be an object');
        }

        const requiredFactors = ['technical', 'sentiment', 'pattern'];
        for (const factor of requiredFactors) {
          if (!value.hasOwnProperty(factor)) {
            throw new Error(`Missing required factor: ${factor}`);
          }
          if (typeof value[factor] !== 'number' || value[factor] < 0 || value[factor] > 1) {
            throw new Error(`Factor ${factor} must be a number between 0 and 1`);
          }
        }
      },
    },
  },
  // Price recommendations
  entryPrice: {
    type: DataTypes.DECIMAL(10, 5),
    allowNull: false,
    validate: {
      min: 0,
    },
  },
  stopLoss: {
    type: DataTypes.DECIMAL(10, 5),
    allowNull: true,
    validate: {
      min: 0,
    },
  },
  takeProfit: {
    type: DataTypes.DECIMAL(10, 5),
    allowNull: true,
    validate: {
      min: 0,
    },
  },
  // Risk management
  riskRewardRatio: {
    type: DataTypes.DECIMAL(4, 2),
    allowNull: true,
    field: 'risk_reward',
    validate: {
      min: 0,
    },
  },
  positionSize: {
    type: DataTypes.DECIMAL(5, 2),
    allowNull: true,
    validate: {
      min: 0,
      max: 100, // Max 100% of account
    },
  },
  // Signal metadata
  source: {
    type: DataTypes.ENUM('ml_engine', 'technical_analysis', 'manual', 'hybrid'),
    allowNull: false,
    defaultValue: 'ml_engine',
  },
  signalStrength: {
    type: DataTypes.ENUM('weak', 'moderate', 'strong', 'very_strong'),
    allowNull: false,
    defaultValue: 'moderate',
  },
  marketCondition: {
    type: DataTypes.ENUM('trending', 'ranging', 'volatile', 'calm'),
    allowNull: true,
  },
  // Technical indicators at signal time
  technicalData: {
    type: DataTypes.JSON,
    allowNull: true,
    defaultValue: {},
  },
  // Signal lifecycle
  status: {
    type: DataTypes.ENUM('active', 'triggered', 'stopped', 'expired', 'cancelled'),
    allowNull: false,
    defaultValue: 'active',
  },
  expiresAt: {
    type: DataTypes.DATE,
    allowNull: true,
  },
  triggeredAt: {
    type: DataTypes.DATE,
    allowNull: true,
  },
  triggeredPrice: {
    type: DataTypes.DECIMAL(10, 5),
    allowNull: true,
  },
  // Performance tracking
  actualOutcome: {
    type: DataTypes.ENUM('win', 'loss', 'breakeven', 'pending'),
    allowNull: true,
    defaultValue: 'pending',
  },
  actualPnL: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: true,
    field: 'actual_pnl',
  },
  actualPnLPercent: {
    type: DataTypes.DECIMAL(6, 2),
    allowNull: true,
    field: 'actual_pnl_percent',
  },
  durationMinutes: {
    type: DataTypes.INTEGER,
    allowNull: true,
  },
  // Notification tracking
  isNotified: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    field: 'is_notified',
  },
  notifiedAt: {
    type: DataTypes.DATE,
    allowNull: true,
    field: 'notified_at',
  },
  notificationChannels: {
    type: DataTypes.JSON,
    defaultValue: [],
    allowNull: false,
  },
  // Analytics data
  marketDataSnapshot: {
    type: DataTypes.JSON,
    allowNull: true,
  },
  backtestId: {
    type: DataTypes.UUID,
    allowNull: true,
  },
}, {
  tableName: 'trading_signals',
  paranoid: false, // Disable soft deletes (no deleted_at column)
  underscored: true, // Database uses snake_case column names
  indexes: [
    {
      fields: ['userId'],
      name: 'user_signals_index',
    },
    {
      fields: ['pair', 'timeframe'],
      name: 'pair_timeframe_signals_index',
    },
    {
      fields: ['signal', 'confidence'],
      name: 'signal_confidence_index',
    },
    {
      fields: ['status'],
      name: 'signal_status_index',
    },
    {
      fields: ['createdAt'],
      name: 'signal_created_index',
    },
    {
      fields: ['expiresAt'],
      name: 'signal_expiry_index',
    },
    {
      fields: ['source'],
      name: 'signal_source_index',
    },
    {
      fields: ['actualOutcome'],
      name: 'signal_outcome_index',
    },
  ],
  validate: {
    /**
     * Validate stop loss and take profit levels
     */
    validateRiskLevels() {
      if (this.signal === 'buy') {
        if (this.stopLoss && this.stopLoss >= this.entryPrice) {
          throw new Error('Stop loss for buy signal must be below entry price');
        }
        if (this.takeProfit && this.takeProfit <= this.entryPrice) {
          throw new Error('Take profit for buy signal must be above entry price');
        }
      } else if (this.signal === 'sell') {
        if (this.stopLoss && this.stopLoss <= this.entryPrice) {
          throw new Error('Stop loss for sell signal must be above entry price');
        }
        if (this.takeProfit && this.takeProfit >= this.entryPrice) {
          throw new Error('Take profit for sell signal must be below entry price');
        }
      }
    },

    /**
     * Validate expiry date
     */
    validateExpiry() {
      if (this.expiresAt && this.expiresAt <= new Date()) {
        throw new Error('Expiry date must be in the future');
      }
    },
  },
});

/**
 * Class method to find active signals for a user
 *
 * @param {string} userId - User ID
 * @param {string} pair - Optional currency pair filter
 * @returns {Promise<TradingSignal[]>} Array of active signals
 */
TradingSignal.findActiveSignals = async function(userId, pair = null) {
  const where = {
    userId,
    status: 'active',
    [sequelize.Op.or]: [
      { expiresAt: null },
      { expiresAt: { [sequelize.Op.gt]: new Date() } },
    ],
  };

  if (pair) {
    where.pair = pair;
  }

  return await this.findAll({
    where,
    order: [['createdAt', 'DESC']],
  });
};

/**
 * Class method to find signals by performance
 *
 * @param {string} outcome - Signal outcome ('win', 'loss', 'breakeven')
 * @param {number} limit - Limit results
 * @returns {Promise<TradingSignal[]>} Array of signals
 */
TradingSignal.findByOutcome = async function(outcome, limit = 100) {
  return await this.findAll({
    where: {
      actualOutcome: outcome,
    },
    order: [['createdAt', 'DESC']],
    limit,
  });
};

/**
 * Class method to get signal statistics
 *
 * @param {string} userId - Optional user ID filter
 * @param {Date} startDate - Optional start date filter
 * @param {Date} endDate - Optional end date filter
 * @returns {Promise<object>} Signal statistics
 */
TradingSignal.getStatistics = async function(userId = null, startDate = null, endDate = null) {
  const where = {};

  if (userId) where.userId = userId;
  if (startDate || endDate) {
    where.createdAt = {};
    if (startDate) where.createdAt[Op.gte] = startDate;
    if (endDate) where.createdAt[Op.lte] = endDate;
  }

  const [totalSignals, winningSignals, losingSignals] = await Promise.all([
    this.count({ where }),
    this.count({ where: { ...where, actualOutcome: 'win' } }),
    this.count({ where: { ...where, actualOutcome: 'loss' } }),
  ]);

  const winRate = totalSignals > 0 ? (winningSignals / totalSignals) * 100 : 0;

  const avgPnL = await this.findOne({
    where: { ...where, actualPnL: { [Op.ne]: null } },
    attributes: [
      [sequelize.fn('AVG', sequelize.col('actual_pnl')), 'avgPnL'],
      [sequelize.fn('SUM', sequelize.col('actual_pnl')), 'totalPnL'],
    ],
    raw: true,
  });

  return {
    totalSignals,
    winningSignals,
    losingSignals,
    winRate: parseFloat(winRate.toFixed(2)),
    averagePnL: avgPnL?.avgPnL ? parseFloat(avgPnL.avgPnL) : 0,
    totalPnL: avgPnL?.totalPnL ? parseFloat(avgPnL.totalPnL) : 0,
  };
};

/**
 * Instance method to expire the signal
 *
 * @returns {Promise<void>}
 */
TradingSignal.prototype.expire = async function() {
  this.status = 'expired';
  await this.save();
};

/**
 * Instance method to trigger the signal
 *
 * @param {number} price - Trigger price
 * @returns {Promise<void>}
 */
TradingSignal.prototype.trigger = async function(price) {
  this.status = 'triggered';
  this.triggeredAt = new Date();
  this.triggeredPrice = price;
  await this.save();
};

/**
 * Instance method to calculate risk-reward ratio
 *
 * @returns {number|null} Risk-reward ratio
 */
TradingSignal.prototype.calculateRiskReward = function() {
  if (!this.stopLoss || !this.takeProfit) return null;

  let risk, reward;

  if (this.signal === 'buy') {
    risk = this.entryPrice - this.stopLoss;
    reward = this.takeProfit - this.entryPrice;
  } else {
    risk = this.stopLoss - this.entryPrice;
    reward = this.entryPrice - this.takeProfit;
  }

  return risk > 0 ? reward / risk : null;
};

/**
 * Instance method to update signal outcome
 *
 * @param {string} outcome - Outcome ('win', 'loss', 'breakeven')
 * @param {number} pnl - Profit/Loss amount
 * @param {number} pnlPercent - Profit/Loss percentage
 * @returns {Promise<void>}
 */
TradingSignal.prototype.updateOutcome = async function(outcome, pnl, pnlPercent) {
  this.actualOutcome = outcome;
  this.actualPnL = pnl;
  this.actualPnLPercent = pnlPercent;

  if (this.triggeredAt) {
    this.durationMinutes = Math.floor((new Date() - this.triggeredAt) / (1000 * 60));
  }

  await this.save();
};

/**
 * Class method to clean expired signals
 *
 * @returns {Promise<number>} Number of expired signals
 */
TradingSignal.cleanExpiredSignals = async function() {
  const result = await this.update(
    { status: 'expired' },
    {
      where: {
        status: 'active',
        expiresAt: {
          [sequelize.Op.lt]: new Date(),
        },
      },
    }
  );

  return result[0]; // Number of affected rows
};

module.exports = TradingSignal;